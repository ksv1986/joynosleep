#!/usr/bin/env python3

import logging
import pyudev
import dbus
import struct
import signal
from threading import Event, Timer, Thread


"""
struct timeval {
    time_t          tv_sec;
    suseconds_t     tv_usec;
};

struct input_event {
	struct timeval time;
	unsigned short type;
	unsigned short code;
	unsigned int value;
};
"""
event_fmt = '@QQHHI'
event_len = struct.calcsize(event_fmt)
event_unpack = struct.Struct(event_fmt).unpack_from


EV_KEY=1 # when any button is pressed on joystick, inhibit screen saver
EV_ABS=3 # ignore axis moves, since joystick could generate noise even when not touched

TIMEOUT=600


class ScreenSaverHandler:
    cookie = None
    saver = None
    timer = None
    udev = None
    event = Event()
    stopped = False
    devices = {}
    timeout = TIMEOUT

    def __init__(self):
        iface = 'org.freedesktop.ScreenSaver'
        self.saver = dbus.Interface(dbus.SessionBus().get_object(iface, '/ScreenSaver'), dbus_interface=iface)
        self.udev = pyudev.Context()
        ScreenSaverHandler.instance = self
        signal.signal(signal.SIGINT, sigint)

    def uninhibit(self):
        if not self.cookie:
            return
        self.cookie = self.saver.UnInhibit(self.cookie)
        logging.info('screen saver resumed')

    def inhibit(self):
        self.cookie = self.cookie or self.saver.Inhibit("joysuspend", "joy pressed")
        logging.info(f'screen saver inhibited for {self.timeout} seconds')

        if self.timer:
            self.timer.cancel()
        self.timer = Timer(self.timeout, self.uninhibit)
        self.timer.start()

    def probe(self, device):
        devname = device.device_node
        if devname and devname.startswith('/dev/input/event'):
            logging.debug(device)
            logging.info(f'{device.device_node} {device.parent.properties["NAME"]}')
            self.start(device)

    def start(self, device):
        t = Thread(target=device_loop, args=(self, device))
        self.devices[device.device_node] = t
        t.start()

    def stop(self):
        self.stopped = True
        for t in self.devices.values():
            t.join()

        self.uninhibit()
        if self.timer:
            self.timer.cancel()
        self.event.set()

    def wait(self):
        self.event.wait()


def is_button_up(e):
    return e[2] == EV_KEY and e[4] == 0


def device_loop(handler, device):
    with open(device.device_node, 'rb') as f:
        while not handler.stopped:
            data = f.read(event_len)
            if not data: break
            e = event_unpack(data)
            if is_button_up(e):
                handler.inhibit()


def sigint(_signum, _frame):
    ScreenSaverHandler.instance.stop()


def main():
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    handler = ScreenSaverHandler()

    for device in handler.udev.list_devices(subsystem='input', ID_INPUT_JOYSTICK='1'):
        handler.probe(device)

    handler.wait()
    logging.info(f'exit')


if __name__ == "__main__":
    main()
