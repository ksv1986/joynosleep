#!/usr/bin/env python3

import logging
import pyudev
import dbus
import struct
import signal
from time import sleep
from threading import Event, Timer, Thread, current_thread


"""
struct timeval {
    time_t          tv_sec;
    suseconds_t     tv_usec;
};

struct input_event {
	struct timeval time;
	unsigned short type;
	unsigned short code;
	unsigned int value;
};
"""
event_fmt = '@QQHHI'
event_len = struct.calcsize(event_fmt)
event_unpack = struct.Struct(event_fmt).unpack_from


EV_KEY=1 # when any button is pressed on joystick, inhibit screen saver
EV_ABS=3 # ignore axis moves, since joystick could generate noise even when not touched

TIMEOUT=600


class ScreenSaverHandler:
    cookie = None
    saver = None
    timer = None
    udev = None
    observer = None
    event = Event()
    devices = {}
    timeout = TIMEOUT
    name = 'joysuspend'

    def __init__(self):
        iface = 'org.freedesktop.ScreenSaver'
        while True:
            try:
                self.saver = dbus.Interface(dbus.SessionBus().get_object(iface, '/ScreenSaver'), dbus_interface=iface)
                break
            except dbus.exceptions.DBusException as ex:
                repeat = 2
                logging.debug(f'dbus exception: {ex}')
                logging.debug(f'will repeat in {repeat} seconds')
                sleep(repeat)

        self.udev = pyudev.Context()
        monitor = pyudev.Monitor.from_netlink(self.udev)
        monitor.filter_by(subsystem='input')
        self.observer = pyudev.MonitorObserver(monitor, callback=device_callback, name=self.name)

        ScreenSaverHandler.instance = self
        signal.signal(signal.SIGINT, sigint)

    def uninhibit(self):
        if not self.cookie:
            return
        self.cookie = self.saver.UnInhibit(self.cookie)
        logging.info('screen saver resumed')

    def inhibit(self):
        self.cookie = self.cookie or self.saver.Inhibit(self.name, "joy pressed")
        logging.info(f'screen saver inhibited for {self.timeout} seconds')

        if self.timer:
            self.timer.cancel()
        self.timer = Timer(self.timeout, self.uninhibit)
        self.timer.start()

    def probe(self, device):
        if not device.properties.get('ID_INPUT_JOYSTICK', None):
            return

        devname = device.device_node
        if devname and devname.startswith('/dev/input/event'):
            self.add(device)

    def add(self, device):
        t = Thread(target=device_loop, args=(self, device))
        self.devices[device.device_node] = t
        t.stopped = False
        t.start()

    def remove(self, device):
        t = self.devices.pop(device.device_node, None)
        if not t:
            return

        logging.info(f'removing {device.device_node}')
        t.stopped = True
        t.join()

    def stop(self):
        self.observer.stop()

        for t in self.devices.values():
            t.stopped = True
        for t in self.devices.values():
            t.join()

        self.uninhibit()
        if self.timer:
            self.timer.cancel()
        self.event.set()

    def run(self):
        for device in self.udev.list_devices(subsystem='input'):
            self.probe(device)

        self.observer.start()
        self.wait()

    def wait(self):
        self.event.wait()


def device_callback(device):
    logging.debug(f'cb {device.action} {device.device_node}')

    handler = ScreenSaverHandler.instance
    if device.action == 'remove':
        handler.remove(device)
    elif device.action == 'add':
        handler.probe(device)


def is_button_up(e):
    return e[2] == EV_KEY and e[4] == 0


def device_loop(handler, device):
    with open(device.device_node, 'rb') as f:
        t = current_thread()
        logging.debug(device)
        logging.info(f'{device.device_node} {device.parent.properties["NAME"]}')
        try:
            while not t.stopped:
                data = f.read(event_len)
                if not data: break
                e = event_unpack(data)
                if is_button_up(e):
                    handler.inhibit()
        except OSError as ex:
            logging.debug(f'{device.device_node}: exception {ex}')


def sigint(_signum, _frame):
    ScreenSaverHandler.instance.stop()


def main():
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    handler = ScreenSaverHandler()
    handler.run()

    logging.info(f'exit')


if __name__ == "__main__":
    main()
